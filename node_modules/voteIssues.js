var dbAccess = require('dbAccess');
var url = require('url');
var g_userVote;
var g_userId;
var g_IssueId;

var VoteIssues = exports.VoteIssues = function() {
};


/**
* Takes care of the voting on issues
*/
function printPage(response) 
{
	return function(error, rows) 
	{	
		if (error) throw error;
	
		if (rows.length == 0) //If the user hasn't voted on this issue
		{	
			var sqlInsertUserVote = "INSERT INTO 'votes' ('user_id', 'issue_id', 'vote') "
				+ "VALUES ('" + g_userId + "', '" + g_IssueId + "', '" + g_userVote + "');";
			dbAccess.runQuery(sqlInsertUserVote, function(error, rows)
			{
				if(error) 
				{
					// If an error is generated
					console.log('Error occured saving Vote to the Database:' + error.toString());					
					response.write('<html><script language=\'JavaScript\'>alert(\'Your vote could not be recorded! There was an error connecting to the database.\'),history.go(-1)</script></html>');
					response.end();
				}
				else  //Successful Vote
				{				
					// After inserting new vote, update the likes/dislikes count in issues table
					VoteIssues.updateIssueVotes(g_IssueId);
					
					//Simply go back to the previous page for now
					response.write('<html><script language=\'JavaScript\'>window.location="/viewIssue?id=' + g_IssueId + '"</script></html>');
					response.end();
				}//Codes by Quackit.com

			});	
		}
		else
		{					
			response.write('<html><script language=\'JavaScript\'>alert(\'Sorry you have already voted!\'),history.go(-1)</script></html>');
			response.end();		
		}
	}
}

/**
* Main function of the module
* @param request Incoming request
* @param response Response object to send the data
*/
VoteIssues.display = function(request, response) 
{
	var parsedURL = url.parse(request.url, true);
	

	/* Select if the user has already voted
	Get the user ID of the logged in user
	NOTE: This should work (albeit with changes) once
	Cody implements his code
	*/
	 //userId = req.getUser().user_id;
	 
	g_userId = 1; //Just for now	 
	g_userVote = parsedURL.query.vote;
	g_IssueId = parsedURL.query.issueid;
		
	if (g_userId == null) {
		//If the user is not logged it, redirect to the static message page
		response.write('<!DOCTYPE HTML><html><head><title>Plese wait</title>');
		response.write('<meta http-equiv="REFRESH" content="0;url=./voteFailed.html"></HEAD><BODY></BODY></HTML>');
		response.end();		
	}
	else {
		var sqlQuery = 'SELECT * FROM votes WHERE issue_id =  ' + g_IssueId + ' AND user_id = ' + g_userId ;			
		//console.log(g_IssueId + " " + g_userId + " " + g_userVote);
		dbAccess.runQuery(sqlQuery, printPage(response));
	}
}


/**
* Function to update the like and dislike vote counts for issues
* @param id of the issue whose votes we wish to update
*/
VoteIssues.updateIssueVotes = function(issueId)
{
	console.log("UPDATING ISSUE VOTES");
	
	var sqlCountLikes = "SELECT count(*) AS 'likes' FROM votes WHERE issue_id=" + issueId + " AND vote=0;";
	dbAccess.runQuery(sqlCountLikes, function(error, rows) {
		var likeCount = rows[0].likes;
		var sqlCountDislikes = "SELECT count(*) AS 'dislikes' FROM votes WHERE issue_id=" + issueId + " AND vote=1;";
		dbAccess.runQuery(sqlCountDislikes, function(error, rows) {
			var dislikeCount = rows[0].dislikes;
			var updateParams = { values:['likes='+likeCount, 'dislikes='+dislikeCount], conditions:['id='+issueId] };
			dbAccess.update('issues', updateParams, function(error, rows) {
				//console.log("likes = " + likeCount + ", dislikes = " + dislikeCount);
			});
		});
	});
}
